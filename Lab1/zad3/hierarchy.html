<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css"
        integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="stylesheet" href="stylesheet.css">
    <title>
        Thinking in Java
    </title>
</head>

<body>
    <header>
        <nav class="navbar navbar-dark bg-primary navbar-expand-lg">
            <a class="navbar-brand" href="index.html"><i class="fas fa-gavel "></i>Java Tutorial</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#mainmenu">
                <i class="fas fa-bars"></i>
            </button>
            <div class="collapse navbar-collapse" id="mainmenu">
                <ul class="navbar-nav mr-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="introduce.html">Introduce</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown"> Objects
                        </a>
                        <div class="dropdown-menu">
                            <a class="dropdown-item" href="abstraction.html">Abstraction</a>
                            <a class="dropdown-item" href="interfaces.html">Interfaces</a>
                            <a class="dropdown-item" href="hierarchy.html">Hierarchy</a>
                            <div class="dropdown-divider"></div>
                            <a class="dropdown-item" href="summarry.html">Summary</a>
                        </div>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="operators.html">Operators</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="author.html">Author</a>
                    </li>
                </ul>
            </div>
        </nav>
    </header>

    <main>
        <div class="row">
            <div class="col-12 col-sm-12 col-md-6 offset-md-3 w-100">
                <h1> Hierarchy </h1>
            </div>
            <div class="col-12 textbox">
                <pre>
                    One of the issues in OOP that has become especially prominent since the introduction of C++
                    is whether all classes should ultimately be inherited from a single base class. In Java (as with
                    virtually all other OOP languages except for C++) the answer is yes, and the name of this
                    ultimate base class is simply Object. It turns out that the benefits of the singly rooted
                    hierarchy are many.

                    All objects in a singly rooted hierarchy have an interface in common, so they are all
                    ultimately the same fundamental type. The alternative (provided by C++) is that you don’t
                    know that everything is the same basic type. From a backward-compatibility standpoint this
                    fits the model of C better and can be thought of as less restrictive, but when you want to do
                    full-on objectoriented programming you must then build your own hierarchy to provide the
                    same convenience that’s built into other OOP languages. And in any new class library you
                    acquire, some other incompatible interface will be used. It requires effort (and possibly
                    multiple inheritance) to work the new interface into your design. Is the extra “flexibility” of
                    C++ worth it? If you need it—if you have a large investment in C—it’s quite valuable. If you’re
                    starting from scratch, other alternatives such as Java can often be more productive.
                    All objects in a singly rooted hierarchy can be guaranteed to have certain functionality. You
                    know you can perform certain basic operations on every object in your system. All objects can
                    easily be created on the heap, and argument passing is greatly simplified.

                    A singly rooted hierarchy makes it much easier to implement a garbage collector, which is
                    one of the fundamental improvements of Java over C++. And since information about the
                    type of an object is guaranteed to be in all objects, you’ll never end up with an object whose
                    type you cannot determine. This is especially important with system-level operations, such as
                    exception handling, and to allow greater flexibility in programming. 

                    In general, you don’t know how many objects you’re going to need to solve a particular
                    problem, or how long they will last. You also don’t know how to store those objects. How can
                    you know how much space to create if that information isn’t known until run time?

                    The solution to most problems in object-oriented design seems flippant: You create another
                    type of object. The new type of object that solves this particular problem holds references to
                    other objects. Of course, you can do the same thing with an array, which is available in most
                    languages. But this new object, generally called a container (also called a collection, but the
                    Java library uses that term in a different sense so this book will use “container”), will expand
                    itself whenever necessary to accommodate everything you place inside it. So you don’t need
                    to know how many objects you’re going to hold in a container. Just create a container object
                    and let it take care of the details.

                    Fortunately, a good OOP language comes with a set of containers as part of the package. In
                    C++, it’s part of the Standard C++ Library and is often called the Standard Template Library
                    (STL). Smalltalk has a very complete set of containers. Java also has numerous containers in
                    its standard library. In some libraries, one or two generic containers is considered good
                    enough for all needs, and in others (Java, for example) the library has different types of
                    containers for different needs: several different kinds of List classes (to hold sequences),
                    Maps (also known as associative arrays, to associate objects with other objects), Sets (to
                    hold one of each type of object), and more components such as queues, trees, stacks, etc.

                    From a design standpoint, all you really want is a container that can be manipulated to solve
                    your problem. If a single type of container satisfied all of your needs, there’d be no reason to
                    have different kinds. There are two reasons that you need a choice of containers. First,
                    containers provide different types of interfaces and external behavior. A stack has a different
                    interface and behavior than a queue, which is different from a set or a list. One of these might
                    provide a more flexible solution to your problem than the other. Second, different containers
                    have different efficiencies for certain operations. For example, there are two basic types of
                    List: ArrayList and LinkedList. Both are simple sequences that can have identical
                    interfaces and external behaviors. But certain operations can have significantly different
                    costs. Randomly accessing elements in an ArrayList is a constant-time operation; it takes
                    the same amount of time regardless of the element you select. However, in a LinkedList it is
                    expensive to move through the list to randomly select an element, and it takes longer to find
                    an element that is farther down the list. On the other hand, if you want to insert an element
                    in the middle of a sequence, it’s cheaper in a LinkedList than in an ArrayList. These and
                    other operations have different efficiencies depending on the underlying structure of the
                    sequence. You might start building your program with a LinkedList and, when tuning for
                    performance, change to an ArrayList. Because of the abstraction via the interface List, you
                    can change from one to the other with minimal impact on your code. 
                </pre>
            </div>
    </main>

    <footer>
        <!-- Tutaj treść stopki / Here the content of the footer -->
        <h4>Oscar Teeninga </h4>
    </footer>

    <script src="http://code.jquery.com/jquery-3.3.1.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"></script>
</body>

</html>